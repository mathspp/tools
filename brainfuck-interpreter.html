<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brainfuck Editor & Interpreter</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/lib/codemirror.min.css">
    <style>
        body {
            max-width: 1000px;
            margin: 0 auto;
            padding: clamp(1.75rem, 3vw, 2.5rem) clamp(1.25rem, 3vw, 2.5rem) clamp(3rem, 5vw, 4rem);
        }

        main {
            display: grid;
            gap: clamp(1.25rem, 2.5vw, 1.75rem);
        }

        .tool-card {
            padding: clamp(1.25rem, 3vw, 2rem);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 0.75rem;
        }

        .card-header h2 {
            margin: 0;
        }

        .CodeMirror {
            height: 420px;
            border: 1px solid var(--ui-3);
            border-radius: var(--radius-md);
            font-family: var(--font-mono);
            font-size: 15px;
        }

        .mode-toggle {
            display: inline-flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .mode-toggle label {
            display: inline-flex;
            gap: 0.35rem;
            align-items: center;
            cursor: pointer;
        }

        .mode-toggle input[type="radio"] {
            width: auto;
            flex: 0 0 auto;
            margin: 0;
        }

        .input-help {
            color: var(--tx-2);
            font-size: 0.95rem;
            margin-top: 0.35rem;
        }

        .output-grid {
            display: grid;
            gap: 0.9rem;
        }

        .output-block {
            background: var(--bg);
            border: 1px solid var(--ui-2);
            border-radius: var(--radius-sm);
            padding: 0.75rem 0.9rem;
            min-height: 80px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .status {
            margin-top: 0.5rem;
            font-size: 0.98rem;
            color: var(--tx-2);
            white-space: pre-wrap;
        }

        .status.error {
            color: var(--re);
        }

        @media (max-width: 720px) {
            body {
                padding: 1.4rem 1rem 2.5rem;
            }

            .CodeMirror {
                height: 320px;
            }
        }
    </style>
</head>

<body>
    <header class="page-header">
        <a class="site-link" href="https://tools.mathspp.com/" aria-label="Back to tools.mathspp.com">← tools.mathspp.com</a>
        <h1>Brainfuck Editor & Interpreter</h1>
        <p class="lead">Write brainfuck code with a CodeMirror editor, feed it ASCII or comma-separated input, and run it
            directly in your browser.</p>
    </header>

    <main>
        <section class="surface tool-card">
            <div class="card-header">
                <h2 class="content-flow" style="--flow-space: 0.1rem;">
                    <span>Program</span>
                    <small style="color: var(--tx-2); font-weight: 500;">Run executes the code below</small>
                </h2>
                <div style="display: inline-flex; gap: 0.5rem; flex-wrap: wrap;">
                    <button type="button" id="save-button" class="secondary">Save</button>
                    <button type="button" id="copy-code-button" class="secondary">Copy code</button>
                    <button type="button" id="copy-permalink-button" class="secondary">Copy permalink</button>
                    <button type="button" id="run-button">Run</button>
                </div>
            </div>

            <label class="sr-only" for="code-input">Brainfuck code</label>
            <textarea id="code-input" name="code-input"></textarea>

            <div class="content-flow" style="--flow-space: 0.35rem; margin-top: 1rem;">
                <div class="mode-toggle" role="group" aria-label="Input mode">
                    <label>
                        <input type="radio" name="input-mode" value="ascii" id="mode-ascii" checked>
                        ASCII
                    </label>
                    <label>
                        <input type="radio" name="input-mode" value="numbers" id="mode-numbers">
                        Comma-separated integers
                    </label>
                </div>
                <label for="bf-input">Program input</label>
                <textarea id="bf-input" name="bf-input" rows="4" placeholder="Type or paste program input, including new lines"></textarea>
                <p class="input-help" id="input-help">ASCII mode sends each character as its byte value, including new lines.</p>
            </div>

            <p class="status" id="status" role="status" aria-live="polite"></p>
        </section>

        <section class="surface tool-card">
            <div class="card-header" style="margin-bottom: 0.35rem;">
                <h2 style="margin: 0;">Output</h2>
            </div>
            <div class="output-grid">
                <div>
                    <div class="input-help">ASCII</div>
                    <div class="output-block" id="output-ascii">(no output)</div>
                </div>
                <div>
                    <div class="input-help">Byte values</div>
                    <div class="output-block" id="output-bytes">(no output)</div>
                </div>
            </div>
        </section>

        <section class="surface tool-card">
            <div class="card-header">
                <h2 style="margin: 0;">Fail-safe settings</h2>
                <p style="margin: 0; color: var(--tx-2); max-width: 48ch;">Prevent runaway programs by stopping execution after a
                    time limit or when the tape grows too large.</p>
            </div>

            <div class="content-flow" style="--flow-space: 0.75rem;">
                <label class="content-flow" style="--flow-space: 0.25rem;">
                    <span>Timeout (seconds)</span>
                    <input id="failsafe-timeout" type="number" min="0" step="1" value="3" style="max-width: 200px;">
                    <small class="input-help">Stops execution after this many seconds. Use 0 for no timeout.</small>
                </label>

                <label class="content-flow" style="--flow-space: 0.25rem;">
                    <span>Tape length limit (cells)</span>
                    <input id="failsafe-tape-limit" type="number" min="0" step="1" value="0" style="max-width: 200px;">
                    <small class="input-help">Interrupts execution if the tape exceeds this length. Use 0 to allow unlimited
                        growth.</small>
                </label>

                <label style="display: inline-flex; gap: 0.5rem; align-items: center;">
                    <input id="failsafe-disabled" type="checkbox">
                    <span>Disable the fail-safe entirely</span>
                </label>
            </div>
        </section>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/lib/codemirror.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/mode/javascript/javascript.min.js"></script>
    <script>
        (function () {
            const runButton = document.getElementById('run-button');
            const saveButton = document.getElementById('save-button');
            const copyCodeButton = document.getElementById('copy-code-button');
            const copyPermalinkButton = document.getElementById('copy-permalink-button');
            const statusEl = document.getElementById('status');
            const outputAscii = document.getElementById('output-ascii');
            const outputBytes = document.getElementById('output-bytes');
            const bfInput = document.getElementById('bf-input');
            const inputHelp = document.getElementById('input-help');
            const asciiModeRadio = document.getElementById('mode-ascii');
            const failsafeTimeoutInput = document.getElementById('failsafe-timeout');
            const failsafeTapeLimitInput = document.getElementById('failsafe-tape-limit');
            const failsafeDisabledInput = document.getElementById('failsafe-disabled');

            const textarea = document.getElementById('code-input');
            const editor = CodeMirror.fromTextArea(textarea, {
                mode: 'text/plain',
                lineNumbers: true,
                indentUnit: 2,
                lineWrapping: true,
                viewportMargin: Infinity,
            });

            const STORAGE_KEY = 'brainfuck-interpreter-code';
            const FAILSAFE_STORAGE_KEY = 'brainfuck-interpreter-failsafe-settings';
            const DEFAULT_FAILSAFE_SETTINGS = {
                timeoutSeconds: 3,
                tapeLengthLimit: 0,
                disabled: false,
            };

            class BrainfuckFailSafeError extends Error {
                constructor(message, debugInfo) {
                    super(message);
                    this.name = 'BrainfuckFailSafeError';
                    this.debugInfo = debugInfo;
                }
            }

            function updateStatus(message, isError = false) {
                statusEl.textContent = message;
                statusEl.classList.toggle('error', isError);
            }

            function saveToLocalStorage(content, silent = false) {
                try {
                    localStorage.setItem(STORAGE_KEY, content);
                    if (!silent) {
                        updateStatus('Saved program to local storage.');
                    }
                } catch (error) {
                    if (!silent) {
                        updateStatus('Unable to save program to local storage.', true);
                    }
                }
            }

            function loadStoredProgram() {
                try {
                    const stored = localStorage.getItem(STORAGE_KEY);
                    if (stored) {
                        editor.setValue(stored);
                        return true;
                    }
                } catch (error) {
                    // Ignore retrieval errors and fall back to an empty editor.
                }
                return false;
            }

            function encodeProgram(program) {
                return btoa(unescape(encodeURIComponent(program)));
            }

            function decodeProgram(encoded) {
                return decodeURIComponent(escape(atob(encoded)));
            }

            function loadProgramFromHash() {
                if (!window.location.hash) return null;
                const rawHash = window.location.hash.slice(1);
                const encodedProgram = rawHash.startsWith('program=') ? rawHash.slice(8) : rawHash;

                try {
                    const decoded = decodeProgram(decodeURIComponent(encodedProgram));
                    saveToLocalStorage(decoded, true);
                    return decoded;
                } catch (error) {
                    return null;
                }
            }

            const programFromHash = loadProgramFromHash();
            const hadStoredProgram = programFromHash === null ? loadStoredProgram() : false;

            if (programFromHash !== null) {
                editor.setValue(programFromHash);
            } else if (!hadStoredProgram) {
                editor.setValue('');
            }

            function clampByte(value) {
                return ((value % 256) + 256) % 256;
            }

            function parseInputs(rawValue, mode) {
                if (!rawValue) return [];

                if (mode === 'ascii') {
                    return Array.from(rawValue, (char) => clampByte(char.charCodeAt(0)));
                }

                return rawValue.split(',')
                    .map(part => part.trim())
                    .filter(Boolean)
                    .map((part, index) => {
                        const numeric = Number(part);
                        if (!Number.isFinite(numeric)) {
                            throw new Error(`Input ${index + 1} is not a valid number: "${part}"`);
                        }
                        return clampByte(numeric);
                    });
            }

            function buildJumpMap(program) {
                const stack = [];
                const map = new Map();

                program.split('').forEach((char, index) => {
                    if (char === '[') {
                        stack.push(index);
                    } else if (char === ']') {
                        const start = stack.pop();
                        if (start === undefined) {
                            throw new Error(`Unmatched ']' at position ${index + 1}`);
                        }
                        map.set(start, index);
                        map.set(index, start);
                    }
                });

                if (stack.length) {
                    throw new Error(`Unmatched '[' at position ${stack[stack.length - 1] + 1}`);
                }

                return map;
            }

            function formatTapeWindow(tape, pointer) {
                const windowSize = Math.min(30, tape.length || 1);
                const halfWindow = Math.floor(windowSize / 2);
                let start = Math.max(0, pointer - halfWindow);
                let end = Math.min(tape.length - 1, start + windowSize - 1);

                if (end - start + 1 < windowSize) {
                    start = Math.max(0, end - windowSize + 1);
                }

                const leftEllipsis = start > 0;
                const rightEllipsis = end < tape.length - 1;
                const cells = tape.slice(start, end + 1).map((value, index) => {
                    const absoluteIndex = start + index;
                    return absoluteIndex === pointer ? `[${value}]` : `${value}`;
                });

                return `${leftEllipsis ? '… ' : ''}${cells.join(' ')}${rightEllipsis ? ' …' : ''}`;
            }

            function getStoredFailsafeSettings() {
                try {
                    const raw = localStorage.getItem(FAILSAFE_STORAGE_KEY);
                    if (!raw) return { ...DEFAULT_FAILSAFE_SETTINGS };
                    const parsed = JSON.parse(raw);
                    return sanitizeFailsafeSettings(parsed);
                } catch (error) {
                    return { ...DEFAULT_FAILSAFE_SETTINGS };
                }
            }

            function sanitizeFailsafeSettings(settings) {
                const timeoutSeconds = Number.isFinite(settings.timeoutSeconds)
                    ? Math.max(0, Math.floor(settings.timeoutSeconds))
                    : DEFAULT_FAILSAFE_SETTINGS.timeoutSeconds;
                const tapeLengthLimit = Number.isFinite(settings.tapeLengthLimit)
                    ? Math.max(0, Math.floor(settings.tapeLengthLimit))
                    : DEFAULT_FAILSAFE_SETTINGS.tapeLengthLimit;
                const disabled = Boolean(settings.disabled);

                return { timeoutSeconds, tapeLengthLimit, disabled };
            }

            function persistFailsafeSettings(settings) {
                try {
                    localStorage.setItem(FAILSAFE_STORAGE_KEY, JSON.stringify(settings));
                } catch (error) {
                    // Ignore persistence errors and continue.
                }
            }

            function applyFailsafeSettings(settings) {
                failsafeTimeoutInput.value = settings.timeoutSeconds;
                failsafeTapeLimitInput.value = settings.tapeLengthLimit;
                failsafeDisabledInput.checked = settings.disabled;
            }

            function collectFailsafeSettingsFromInputs() {
                const settings = sanitizeFailsafeSettings({
                    timeoutSeconds: Number(failsafeTimeoutInput.value),
                    tapeLengthLimit: Number(failsafeTapeLimitInput.value),
                    disabled: failsafeDisabledInput.checked,
                });
                persistFailsafeSettings(settings);
                return settings;
            }

            function runProgram(program, inputs, failsafeSettings) {
                const commands = program.replace(/[^\>\<\+\-\.\,\[\]]/g, '');
                const jumpMap = buildJumpMap(commands);

                const tape = [0];
                let pointer = 0;
                let inputIndex = 0;
                let ip = 0;
                const output = [];
                const timeoutMs = failsafeSettings.timeoutSeconds * 1000;
                const startTime = performance.now();

                function enforceFailSafe(message) {
                    const debugInfo = [
                        `Tape length: ${tape.length}`,
                        `Pointer position: ${pointer}`,
                        `Tape window: ${formatTapeWindow(tape, pointer)}`,
                    ].join('\n');
                    throw new BrainfuckFailSafeError(message, debugInfo);
                }

                while (ip < commands.length) {
                    if (!failsafeSettings.disabled && failsafeSettings.timeoutSeconds > 0 && performance.now() - startTime > timeoutMs) {
                        enforceFailSafe(`Execution timed out after ${failsafeSettings.timeoutSeconds} second${failsafeSettings.timeoutSeconds === 1 ? '' : 's'}.`);
                    }

                    const instruction = commands[ip];
                    switch (instruction) {
                        case '>':
                            pointer += 1;
                            if (pointer === tape.length) {
                                tape.push(0);
                            }
                            break;
                        case '<':
                            pointer = Math.max(0, pointer - 1);
                            break;
                        case '+':
                            tape[pointer] = clampByte(tape[pointer] + 1);
                            break;
                        case '-':
                            tape[pointer] = clampByte(tape[pointer] - 1);
                            break;
                        case '.':
                            output.push(tape[pointer]);
                            break;
                        case ',':
                            if (inputIndex < inputs.length) {
                                tape[pointer] = inputs[inputIndex++];
                            }
                            break;
                        case '[':
                            if (tape[pointer] === 0) {
                                ip = jumpMap.get(ip);
                            }
                            break;
                        case ']':
                            if (tape[pointer] !== 0) {
                                ip = jumpMap.get(ip);
                            }
                            break;
                    }

                    if (!failsafeSettings.disabled && failsafeSettings.tapeLengthLimit > 0 && tape.length > failsafeSettings.tapeLengthLimit) {
                        enforceFailSafe(`Execution stopped because the tape exceeded ${failsafeSettings.tapeLengthLimit} cell${failsafeSettings.tapeLengthLimit === 1 ? '' : 's'}.`);
                    }
                    ip += 1;
                }

                return output;
            }

            function renderOutput(bytes) {
                const ascii = String.fromCharCode(...bytes);
                outputAscii.textContent = ascii || '(no output)';
                outputBytes.textContent = bytes.length ? bytes.join(', ') : '(no output)';
            }

            function updateInputHelp() {
                if (asciiModeRadio.checked) {
                    inputHelp.textContent = 'ASCII mode sends each character, including new lines, as its byte value.';
                    bfInput.placeholder = 'Type or paste text, including multi-line input';
                } else {
                    inputHelp.textContent = 'Number mode expects comma-separated integers; values wrap within 0-255.';
                    bfInput.placeholder = 'e.g. 65, 66, 67 for A, B, C';
                }
            }

            runButton.addEventListener('click', () => {
                try {
                    const mode = asciiModeRadio.checked ? 'ascii' : 'numbers';
                    const inputs = parseInputs(bfInput.value, mode);
                    const program = editor.getValue();
                    const output = runProgram(program, inputs, collectFailsafeSettingsFromInputs());
                    renderOutput(output);
                    updateStatus(`Program ran successfully. Output length: ${output.length} byte${output.length === 1 ? '' : 's'}.`);
                } catch (error) {
                    const debugDetails = error instanceof BrainfuckFailSafeError && error.debugInfo
                        ? `${error.message}\n\nDebug info:\n${error.debugInfo}`
                        : error.message;
                    updateStatus(debugDetails, true);
                    outputAscii.textContent = '(no output)';
                    outputBytes.textContent = '(no output)';
                }
            });

            saveButton.addEventListener('click', () => {
                saveToLocalStorage(editor.getValue());
            });

            async function copyToClipboard(text, successMessage, failureMessage) {
                if (!navigator.clipboard) {
                    updateStatus('Clipboard access is not available in this browser.', true);
                    return;
                }

                try {
                    await navigator.clipboard.writeText(text);
                    updateStatus(successMessage);
                } catch (error) {
                    updateStatus(failureMessage, true);
                }
            }

            copyCodeButton.addEventListener('click', () => {
                copyToClipboard(editor.getValue(), 'Copied code to clipboard.', 'Unable to copy code to clipboard.');
            });

            copyPermalinkButton.addEventListener('click', () => {
                const encoded = encodeURIComponent(encodeProgram(editor.getValue()));
                const permalink = `${window.location.origin}${window.location.pathname}#program=${encoded}`;
                history.replaceState(null, '', `#program=${encoded}`);
                copyToClipboard(permalink, 'Copied permalink to clipboard.', 'Unable to copy permalink to clipboard.');
            });

            asciiModeRadio.addEventListener('change', updateInputHelp);
            document.getElementById('mode-numbers').addEventListener('change', updateInputHelp);
            updateInputHelp();

            applyFailsafeSettings(getStoredFailsafeSettings());
            [failsafeTimeoutInput, failsafeTapeLimitInput].forEach((input) => {
                input.addEventListener('input', () => {
                    collectFailsafeSettingsFromInputs();
                });
            });
            failsafeDisabledInput.addEventListener('change', () => {
                collectFailsafeSettingsFromInputs();
            });

            const initialStatus = programFromHash !== null
                ? 'Loaded program from URL and saved to local storage.'
                : hadStoredProgram
                    ? 'Loaded program from local storage.'
                    : 'Ready to run. Tape starts at 0 and overflows/underflows within 0-255.';
            updateStatus(initialStatus);

            editor.on('change', () => {
                saveToLocalStorage(editor.getValue(), true);
            });

            setInterval(() => {
                saveToLocalStorage(editor.getValue(), true);
            }, 5000);
        })();
    </script>
</body>

</html>
